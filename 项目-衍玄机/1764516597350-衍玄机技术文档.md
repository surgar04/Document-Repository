---
title: 衍玄机
subtitle: 技术文档
authors: [Sur方糖]
tags: [TS, CoCos]
createdAt: 2025/11/11
Version: 0.1
Last Modified: 2025/11/11
---
# 衍玄机技术文档 TDD

## 项目概述

衍玄机是基于Cocos Creator + TypeScript开发的 2D 修仙题材游戏，核心玩法待定

## 技术栈

- 引擎：Cocos Creator 3.8.7
- 开发语言：TypeScript
- 资源格式：纹理（WebP/PNG）、骨骼动画（Spine）、音频（MP3/OGG）、配置表（JSON/CSV）

## 核心技术需求

- 地图无缝加载
- 自定义渲染管线实现法术特效，境界特效等
- UI层高频交互优化，如对象池复用，内存缓存
- 自动化构建与分发
- 包体大小优化，性能优化等

## 游戏架构设计
> 客户端架构 分层架构+ECS
- 表现层：基于Cocos 节点树实现，负责渲染，UI，动画等
- 逻辑层：基于ECS实现，负责游戏核心逻辑，如战斗，任务，社交等
- 数据层：本地存储，配置表，网络数据管理，存档等加密保存在本地，游戏数值使用配置表
- 基础设施层：资源管理、网络通信、日志、云控
```typescript
// 核心模块划分示例
export module Game {
  export const Resource = new ResourceManager(); // 资源管理
  export const Scene = new SceneManager(); // 场景管理
  export const UI = new UIManager(); // UI管理
  export const Battle = new BattleSystem(); // 战斗系统
  export const Network = new NetworkManager(); // 网络
}
```

> 关键模块设计

|  模块   | 描述  |  技术点  |
|  ----  | ----  | ----  |
| 资源管理器  | 资源加载、缓存、卸载、依赖管理 | Asset Bundle、异步加载、引用计数|
| 场景管理器  | 大地图分块加载、无缝传送、场景切换动画 |分块渲染、异步场景加载|
| UI 管理器  | UI 预制体加载、层级管理、内存缓存、对象池 | 内存常驻池、对象池复用 |
| 战斗系统  | 游戏逻辑、技能释放、伤害计算、特效同步 | 状态机、事件驱动 |
| 渲染系统  | 自定义材质、Shader、渲染管线控制 | 自定义 Pipeline、GLSL ES |
| 性能监控器  | 帧率、内存、DrawCall、加载时间监控，异常上报 | 性能钩子、日志埋点 |

## 核心功能技术实现
> 地图数据结构
- Chunk：将地图切割为n个像素的区块，每个区块作为独立资源包，切割区块大小视实际地图大小而定 Asset Bundle
- 区块数据应包含：地形纹理（如果有），碰撞信息，NPC坐标，传送点，环境物体

> 无缝加载实现
- 视口检测：通过玩家当前位置，计算视口范围内的3x3区块
- 异步加载：使用AssetBundle.loadDirAsync后台加载即将进入视口的区块，加载完成后通过节点池复用区块节点
- 卸载策略：当区块超出视口范围（如距离玩家 5 个区块外），延迟卸载资源（保留 10 秒缓存，避免频繁加载）

> 传送实现
- 传送点配置目标区块坐标和偏移量
- 触发传送时，异步预加载目标区块及相邻区块
- 用淡入淡出掩盖加载间隙（加载完成前保持特效，完成后瞬间切换坐标）

```typescript
// 区块加载伪代码示例
async loadChunks(centerChunk: Vec2) {
  const loadRange = 3; // 加载中心区块周围3x3范围
  for (let x = -loadRange; x <= loadRange; x++) {
    for (let y = -loadRange; y <= loadRange; y++) {
      const chunkPos = new Vec2(centerChunk.x + x, centerChunk.y + y);
      if (!this.loadedChunks.has(chunkPos)) {
        // 从AssetBundle异步加载区块
        const bundle = await Game.Resource.loadBundle(`chunk_${chunkPos.x}_${chunkPos.y}`);
        const chunkPrefab = await bundle.loadAsync<Prefab>("chunk");
        const chunkNode = instantiate(chunkPrefab);
        this.mapRoot.addChild(chunkNode);
        this.loadedChunks.set(chunkPos, chunkNode);
      }
    }
  }
  // 卸载超出范围的区块
  this.unloadOutOfRangeChunks(centerChunk, loadRange + 2);
}
```

> 自定义渲染管线 基于 Cocos Creator 的CustomPipeline扩展实现

> 渲染层级划分
- 底层：地图、静态物体（不透明）
- 中层：角色、NPC（半透明 / 不透明）
- 高层：特效，光晕（ additive 混合模式）
- 后期：全屏泛光、色调调整

> 核心 Shader
- 灵气流动：噪声纹理（Noise Texture）实现 UV 动画，叠加半透明颜色模拟灵气环绕效果
- 法术特效：径向模糊（Radial Blur）+ 粒子缩放动画，配合颜色渐变（从亮到暗）
- 境界突破：全屏闪光 + 径向扩散遮罩，通过stencil buffer控制显示范围

其他Shader效果等待后期扩展

```glsl
// 灵气流动Shader片段伪代码示例（GLSL ES）
void main() {
  vec2 uv = v_uv;
  // 噪声纹理动画
  uv.x += u_time * 0.1;
  float noise = texture(u_noiseTexture, uv).r;
  // 透明度随噪声和时间变化
  float alpha = sin(u_time) * 0.2 + noise * 0.5;
  gl_FragColor = vec4(u_color.rgb, alpha);
}
```

> 特效管理
- 对象池：采用对象池管理特效实例（如法术、光效），避免频繁创建 / 销毁节点
- 特效资源预加载：进入战斗场景前，预加载常用技能特效到内存

## UI
> UI层级设计
- 常驻层：主界面（血条、 minimap、快捷按钮），加载后常驻内存。
- 动态层：弹窗（背包、任务、设置等），按需加载，关闭后回收至对象池。
- 顶层：提示、加载动画，优先级最高

> 加载优化策略
- 高频UI加载后不销毁，仅隐藏 active = false
- 低频UI使用对象池缓存节点，保留5个实例
- 合并静态 UI 元素为图集（Atlas），减少 DrawCall
- 复杂列表（如背包）使用虚拟列表（仅渲染可视区域内的项）
```typescript
// UI对象池伪代码示例
export class UIPool {
  private pools: Map<string, Node[]> = new Map();

  // 获取UI实例
  async get(prefabPath: string): Promise<Node> {
    if (!this.pools.has(prefabPath)) this.pools.set(prefabPath, []);
    const pool = this.pools.get(prefabPath)!;
    if (pool.length > 0) {
      const node = pool.pop()!;
      node.active = true;
      return node;
    }
    // 池为空时加载新实例
    const prefab = await Game.Resource.load<Prefab>(prefabPath);
    return instantiate(prefab);
  }

  // 回收UI实例
  recover(prefabPath: string, node: Node) {
    node.active = false;
    this.pools.get(prefabPath)?.push(node);
    // 限制池大小，避免内存溢出
    if (this.pools.get(prefabPath)!.length > 5) {
      const excess = this.pools.get(prefabPath)!.shift();
      excess?.destroy();
    }
  }
}
```

## 资源管理与优化
> 资源打包策略
- 按场景划分 Asset Bundle：大地图区块、城镇、副本分别打包，减少初始包体
- 共享资源包：将通用资源（角色模型、技能图标、UI 预制体）放入common包，避免重复打包
- 资源压缩：
  - 纹理：移动端使用 ETC1/ETC2 压缩，H5 端使用 WebP（质量 70%），尺寸限制为 2 的幂次方（如 512x512）
  - 音频：背景音乐（MP3，128kbps），音效（OGG，96kbps）
  - 配置表：CSV 转二进制（节省解析时间和空间）

> 资源加载优先级
- 同步加载：仅用于启动时必要资源（启动图、加载动画）
- 高优先级：玩家角色、当前场景区块、UI 主界面
- 中优先级：NPC、环境互动物体
- 低优先级：远景装饰、背景音效

## 性能优化
> 渲染性能
- DrawCall 优化：
  - 合并静态节点（如地图区块）为合并网格（Static Batch）
  - UI 元素使用图集（Atlas），避免单个小图单独渲染
  - 半透明物体（特效、角色）按距离排序渲染，减少重复绘制
  - 大地图远景使用低精度纹理，关闭不必要的特效
  - 通过cullingMask或自定义脚本剔除视口外的节点渲染

> 脚本性能
- 避免在update中执行复杂逻辑，高频事件（如移动）使用节流（throttle）
- 战斗逻辑使用状态机替代大量if-else，减少分支判断
- 数据遍历优先使用for循环，避免forEach，减少函数调用开销

> 内存优化
- 资源引用计数：加载时 + 1，卸载时 - 1，计数为 0 时释放资源
- 图片资源：根据设备性能动态加载不同分辨率（如低配机加载 512x512 纹理，高配机加载 1024x1024）
- 配置表：仅在需要时解析，解析后转为弱引用（WeakMap）存储

## 构建、打包与分发
> 构建优化
- 代码压缩：启用 Cocos 构建选项中的 “代码混淆” 和 “压缩”，移除调试信息
- 资源剔除：通过settings.package.include配置，仅打包当前平台所需资源
- 引擎裁剪：使用 Cocos 的 “模块裁剪” 功能，移除未使用的模块

> 包体优化
- 初始包体大小< 200MB
- 热更新：使用 Cocos 的 AssetManager 实现热更新，将非核心资源通过服务器下发

> CI/CD
- 工具：Jenkins + GitLab
- 流程：
  - 提交代码到 GitLab，触发 CI 流水线
  - 动执行代码检查（ESLint）、单元测试（Jest）
  - 测试通过后，自动构建多平台包
  - 构建完成后，上传到测试平台，并发送通知

## 反作弊
> 内存数据保护
- 关键数值加密存储：客户端本地存储的敏感数据（如当前修为、背包道具数量、已完成任务 ID）采用AES-256 加密，密钥通过服务器动态下发（每次启动生成临时密钥，有效期 1 小时），避免固定密钥被逆向破解
- 内存校验机制：对运行时关键数值（如角色当前气血、灵力值）定期进行内存哈希校验（每 30 秒计算一次数值的 MD5 哈希，与服务器缓存值比对），若发现不匹配，触发警告并冻结操作，记录设备指纹并上报
- TypeScript 代码混淆：使用 Terser、JavaScript Obfuscator 等工具对编译后的 JS 代码进行混淆（变量名替换为无意义字符、增加冗余逻辑、控制流平坦化）

> 反调试保护
- 客户端启动时检测是否有调试器（如 Chrome DevTools、IDA Pro）附加，通过debugger语句陷阱、检测performance.now()时间差等方式识别调试行为
- 发现调试行为后，触发 “伪随机错误”（如战斗计算结果异常、UI 错乱），同时静默上报设备指纹
- 完整性校验：客户端核心脚本，在启动时计算 SHA-256 哈希，与服务器预存的基准哈希比对，若不匹配（如被篡改替换），禁止进入游戏并提示 “客户端异常”

> 环境作弊检测
- 模拟器 / 虚拟机检测：通过检测设备硬件信息（如 GPU 型号、电池状态、传感器数据）识别模拟器环境，对模拟器账号限制高频操作，防止多开脚本刷资源
- 客户端定期向服务器上报 “操作时间戳”（如移动步数、技能释放间隔），服务器通过时间差分析,识别加速行为
- 客户端内置 “时间基准校验”：通过与服务器同步的 UTC 时间对比本地系统时间，若本地时间流速异常（如被加速），临时修正游戏逻辑时间（如战斗回合时长强制按服务器时间计算）

> 脚本自动化检测
- 监控用户输入模式（如点击坐标、滑动轨迹），通过算法识别 “非人类行为”（如点击间隔标准差 < 50ms、滑动轨迹为直线）

> 核心逻辑服务器中心化
- 战斗计算完全上移：客户端仅发送 “技能选择”“目标选择” 等操作指令，服务器负责计算伤害、命中、闪避、特效触发等核心逻辑，返回结果给客户端仅用于表现
```typescript
// 服务器战斗逻辑伪代码示例
class BattleServer {
  handleSkillCast(playerId: string, skillId: number, targetId: string) {
    // 校验技能合法性（是否已解锁、灵力是否足够等）
    const player = this.getPlayer(playerId);
    if (!player.skills.has(skillId) || player.mana < this.getSkillManaCost(skillId)) {
      return { error: "无效操作" }; // 拒绝客户端非法请求
    }
    // 服务器计算伤害
    const damage = this.calcDamage(player, targetId, skillId);
    // 更新目标状态并返回结果
    this.updateTargetHp(targetId, damage);
    return { damage, targetHp: this.getTargetHp(targetId) };
  }
}
```
- 资源获取强校验：玩家获取道具、修为、灵石等资源时，服务器需验证 “获取来源合法性”（如任务奖励需校验任务是否完成、怪物掉落需校验怪物是否被该玩家击杀），拒绝无来源的资源增加请求
- 境界突破防篡改：修仙境界突破的条件由服务器校验，客户端仅展示进度，突破成功与否完全由服务器判定（防止客户端伪造 “突破成功” 跳过条件）

> 网络请求加密
- 传输层加密：所有网络请求采用HTTPS + TLS 1.3，防止中间人攻击（MITM）拦截数据
- 应用层自定义加密：在 HTTPS 基础上，对请求体和响应体进行二次加密，使用 RC4 流加密，密钥基于设备指纹 + 服务器时间戳动态生成，避免 HTTPS 被破解后直接获取明文协议
```typescript
// 客户端请求加密伪代码示例
const encryptRequest = (data: any, timestamp: number) => {
  const key = md5(deviceFingerprint + timestamp); // 动态生成密钥
  return {
    data: RC4.encrypt(JSON.stringify(data), key),
    timestamp,
    sign: md5(JSON.stringify(data) + key) // 数据签名
  };
};
```
- 防重放攻击：每个请求包含唯一随机数（nonce）+ 时间戳，服务器记录已使用的 nonce（有效期 5 分钟），拒绝重复请求；时间戳与服务器时差超过 30 秒的请求直接丢弃
- 资源包签名验证：热更新的资源包（如地图区块、特效资源）必须包含服务器签名（使用 RSA 非对称加密），客户端验证签名通过后才加载，防止恶意替换资源包植入作弊逻辑

## 相关文档
- Cocos Creator 官方文档：https://docs.cocos.com/creator/manual/zh/
- TypeScript 手册：https://www.typescriptlang.org/docs/
- Asset Bundle 资源管理：https://docs.cocos.com/creator/manual/zh/asset/bundle.html
